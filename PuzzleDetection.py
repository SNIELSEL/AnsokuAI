from colorama import init, Fore, Back, Style
from PIL import Image, ImageDraw,ImageGrab
from lib2to3.pytree import convert
from webbrowser import Chrome
from GetImage import *
import numpy as np
import cv2 as cv
import os
import sys

# Use the same ConsoleRedirect instance if provided
if hasattr(sys.modules[__name__], 'console_redirect'):
    sys.stdout = sys.modules[__name__].console_redirect
    sys.stderr = sys.modules[__name__].console_redirect

# Initialize colorama with the same settings
init(strip=False, convert=False, autoreset=True)

#Text Settings for rectangle text
font = cv.FONT_HERSHEY_TRIPLEX
font_scale = 0.3
thickness = 1

def SearchForPuzzlePieces(ImageFolder, scanImage):

    image_variants = []

    #convert pillow screenshot to opencv image
    scanImage_cv = np.array(scanImage)
    scanImage_cv = cv.cvtColor(scanImage_cv, cv.COLOR_RGB2BGR)

    original_img = scanImage_cv

    original_height, original_width = original_img.shape[:2]
    new_width, new_height = original_width // 2, original_height // 2
    original_img = cv.resize(original_img, (new_width, new_height))

    #use pillow library Image functione to get a image
    img = scanImage
    #Manually set tuple(a kind of vector2) to later use to cover image
    variants = [
        [((1220, 1040), (1355, 1200)), ((1355, 1040), (1500, 1200)), ((0, 0), (1060, 1440)), ((0, 0), (2560, 1050)), ((0, 1200), (2560, 1440)), ((1500, 1040), (2560, 1440))],
        [((1040, 1040), (1200, 1200)), ((1355, 1040), (1500, 1200)), ((0, 0), (1060, 1440)), ((0, 0), (2560, 1050)), ((0, 1200), (2560, 1440)), ((1500, 1040), (2560, 1440))],
        [((1040, 1040), (1200, 1200)), ((1200, 1040), (1355, 1200)), ((0, 0), (1060, 1440)), ((0, 0), (2560, 1050)), ((0, 1200), (2560, 1440)), ((1500, 1040), (2560, 1440))]
    ]

    #creates an alternate image and covers some places with black to make sure that the image recognition is more accurate
    for i, rects in enumerate(variants, 1):
        variant_img = img.copy()
        draw = ImageDraw.Draw(variant_img)
    
        for rect in rects:
            draw.rectangle(rect, fill="black")
    
        image_variants.append(variant_img)


    for variant_img in image_variants:

        mostMatchingPiece = dict(name = "Empty", dictTop_left = 0, dictBottom_right = 0, dictMax_val = 0)

        #converts the pillow lib image to a opencv image to use in image recognition
        variant_img_cv = np.array(variant_img)
        variant_img_cv = cv.cvtColor(variant_img_cv, cv.COLOR_RGB2BGR)
        
        #resize for better view when debugging
        original_height, original_width = variant_img_cv.shape[:2]
        new_width, new_height = original_width // 2, original_height // 2
        variantResized_img = cv.resize(variant_img_cv, (new_width, new_height))

        #cv.imshow("Result", variantResized_img)
        #cv.waitKey()

        #sycles through all puzzle pieces
        for root, _, files in os.walk(ImageFolder):
            for file in files:

                if (file.endswith(".png")):
                    file_path = os.path.join(root, file)
                    imageWithoutExstension, _ = os.path.splitext(file)

                    puzzlePiece_img = cv.imread(file_path, cv.IMREAD_REDUCED_COLOR_2)
                    result = cv.matchTemplate(variantResized_img, puzzlePiece_img, cv.TM_CCOEFF_NORMED)

                    #gives values of whitest and blackest place and their location of the black and white image generated by the matchTemplate
                    min_val, max_val, min_loc, max_loc = cv.minMaxLoc(result)

                    matchingImageThreshold = 0.78
                    if(max_val >= matchingImageThreshold):
                        print(Fore.GREEN + f"{imageWithoutExstension} matches at: {max_loc} with a white value of {max_val}")

                        #getting the dimensions of the image to later use to draw the rectangle
                        puzzlePieceData_w = puzzlePiece_img.shape[1]
                        puzzlePieceData_h = puzzlePiece_img.shape[0]

                        top_left = max_loc
                        bottom_right = (top_left[0] + puzzlePieceData_w, top_left[1] + puzzlePieceData_h)

                        if(max_val >= mostMatchingPiece.get("dictMax_val")):
                            mostMatchingPiece = dict(name = imageWithoutExstension, dictTop_left = top_left, dictBottom_right = bottom_right, dictMax_val = max_val)
     
                    else:
                        print(Fore.RED + f"Nothing found for {imageWithoutExstension} its white value was {max_val}")


        if(mostMatchingPiece.get("name") != "Empty"):
            
            #Get the center of the best matching piece to add text to the rectangle for extra debugging info
            center_x = (mostMatchingPiece.get("dictTop_left")[0] + mostMatchingPiece.get("dictBottom_right")[0]) // 2
            center_y = (mostMatchingPiece.get("dictTop_left")[1] + mostMatchingPiece.get("dictBottom_right")[1]) // 2

            text_size = cv.getTextSize(mostMatchingPiece.get("name"), font, font_scale, thickness)[0]
            text_width, text_height = text_size

            #Set text to center
            text_x = center_x - (text_width // 2)
            text_y = center_y + (text_height // 2)

            cv.rectangle(original_img, mostMatchingPiece.get("dictTop_left"), mostMatchingPiece.get("dictBottom_right"), color=(0,200,0), thickness=2, lineType=cv.LINE_4)
            cv.putText(original_img, mostMatchingPiece.get("name"), (text_x, text_y), font, font_scale, (0, 0, 0), thickness)
            #print(Fore.WHITE + str(mostMatchingPiece))


    return original_img

    print(Fore.RED + "")
    exitAnswer = input(Fore.WHITE + "scan again?: ").strip().lower()
    if exitAnswer == "yes" or exitAnswer == "y":
        from GetImage import GetGameImage
        puzzlePieceFolder = "PuzzlePieces/"
        chromeTabTitle = "unity web player"
        GetGameImage(puzzlePieceFolder, chromeTabTitle)
    elif exitAnswer == "no" or exitAnswer == "n":
        os._exit(1)
    else:
        print("Invalid input. Please type 'yes' or 'no'.")